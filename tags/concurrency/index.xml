<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>concurrency - 标签 - 马力神的博客</title><link>http://example.org/tags/concurrency/</link><description>concurrency - 标签 - 马力神的博客</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>1045772673@qq.com (马力神)</managingEditor><webMaster>1045772673@qq.com (马力神)</webMaster><lastBuildDate>Sun, 10 Jan 2021 23:27:01 +0800</lastBuildDate><atom:link href="http://example.org/tags/concurrency/" rel="self" type="application/rss+xml"/><item><title>Concurrency Patterns In Go</title><link>http://example.org/concurrency/</link><pubDate>Sun, 10 Jan 2021 23:27:01 +0800</pubDate><author>作者</author><guid>http://example.org/concurrency/</guid><description>什么是并发编程 抛开具体的概念 (相信你已经熟知)，并发 concurrency 是一种设计：
将程序设计成一个包含许多独立过程的集合； 允许这些过程最终可以并行 parallel 地去执行； 尽管 并发 并不要求必须同时运行，例如在单核 CPU 物理机上无法实现并行却可以依靠操作系统时间片轮转等调度来实现并发； 并发是一种操作系统在时间维度的虚拟，即时分复用。
代码运行的结果总是相同，无论是以并行还是顺序的方式。 具体要求 通过划分多个独立的任务来将代码以及数据分组 没有竞争条件1 没有死锁2 比常规的程序更有效，即执行更快 Go如何并发 Don&amp;rsquo;t communicate by sharing memory; share memory by communicating. (R. Pike)
不要通过共享内存来通信，这意味着不同的并发实体不应该通过遵守严格、容易出错的内存可见性和同步策略 (比如内存屏障3)来进行通信 (这是可以做到的，但是会让情况变得复杂，而且由于数据竞争会造成不可预期的结果)。
应该通过通信来共享内存 (数据) : Go 使用了基于 CSP4 (Communicating Sequential Process，通信顺序程序) 的并发模型，goroutine 做为并发通信的实体，通过 channel 来实现数据共享。
A send on a channel happens before the corresponding receive from that channel completes.</description></item></channel></rss>