<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>所有文章 - 马力神的博客</title><link>http://example.org/posts/</link><description>所有文章 | 马力神的博客</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>1045772673@qq.com (马力神)</managingEditor><webMaster>1045772673@qq.com (马力神)</webMaster><lastBuildDate>Mon, 19 Apr 2021 15:12:36 +0800</lastBuildDate><atom:link href="http://example.org/posts/" rel="self" type="application/rss+xml"/><item><title>使用GORM IN查询的一个问题</title><link>http://example.org/gorm_20210419/</link><pubDate>Mon, 19 Apr 2021 15:12:36 +0800</pubDate><author>作者</author><guid>http://example.org/gorm_20210419/</guid><description><![CDATA[问题背景 这是一个我在开发过程中遇到的小问题，为了简单，现假设有一张 user 表，结构如下：
1 2 3 4 5 6 7  CREATETABLE`user`(`id`intNOTNULLAUTO_INCREMENT,`name`varchar(20)NOTNULLDEFAULT&#39;&#39;COMMENT&#39;用户名&#39;,`age`tinyint(4)unsignedNOTNULLDEFAULT&#39;0&#39;COMMENT&#39;年龄&#39;,PRIMARYKEY(`id`),KEY`idx_name`(`name`))ENGINE=InnoDBAUTO_INCREMENT=6DEFAULTCHARSET=utf8mb4;  对应的 GORM Model：
1 2 3 4 5 6 7 8 9  type User struct { ID int `gorm:&#34;primaryKey;column:id&#34;` Name string `gorm:&#34;column:name;varchar(20);not null;default&#34;` Age uint8 `gorm:&#34;column:age;tinyint unsigned;not null;default&#34;` } func (u User) TableName() string { return &#34;user&#34; }   在 MySQL 中年龄 age 被定义为一个 tinyint unsigned 类型，范围是 0-255 ，对应 Go 代码中定义的类型为 uint8 。
插入一条测试数据:]]></description></item><item><title>Concurrency Patterns In Go</title><link>http://example.org/concurrency/</link><pubDate>Sun, 10 Jan 2021 23:27:01 +0800</pubDate><author>作者</author><guid>http://example.org/concurrency/</guid><description>什么是并发编程 并发 concurrency 是一种设计：
将程序设计成一个包含许多独立过程的集合； 允许这些过程最终可以并行 parallel 地去执行； 尽管 并发 并不要求必须同时运行，例如在单核 CPU 物理机上无法实现并行却可以依靠操作系统时间片轮转等调度来实现并发； 并发是一种操作系统在时间维度的虚拟，即时分复用。
代码运行的结果总是相同，无论是以并行还是顺序的方式。 具体要求 通过划分多个独立的任务来将代码以及数据分组 没有竞争条件1 没有死锁2 比常规的程序更有效，即执行更快 Go如何并发 Don&amp;rsquo;t communicate by sharing memory; share memory by communicating. (R. Pike)
不要通过共享内存来通信，这意味着不同的并发实体不应该通过遵守严格、容易出错的内存可见性和同步策略 (比如内存屏障3)来进行通信 (这是可以做到的，但是会让情况变得复杂，而且由于数据竞争会造成不可预期的结果)。
应该通过通信来共享内存 (数据) : Go 使用了基于 CSP4 (Communicating Sequential Process，通信顺序程序) 的并发模型，goroutine 做为并发通信的实体，通过 channel 来实现数据共享。
A send on a channel happens before the corresponding receive from that channel completes.</description></item></channel></rss>