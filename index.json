[{"categories":["Go语言学习","设计模式学习笔记"],"content":"单例模型 ","date":"2021-05-19","objectID":"/design-pattern-singleton/:1:0","tags":["design pattern","Go"],"title":"设计模式-单例模式","uri":"/design-pattern-singleton/"},{"categories":["Go语言学习","设计模式学习笔记"],"content":"定义 单例（Singleton）模式的定义：指一个类只有一个实例，且该类能自行创建这个实例的一种模式。例如，Windows 中只能打开一个任务管理器，这样可以避免因打开多个任务管理器窗口而造成内存资源的浪费，或出现各个窗口显示内容的不一致等错误。 在计算机系统中，还有 Windows 的回收站、操作系统中的文件系统、多线程中的线程池、显卡的驱动程序对象、打印机的后台处理服务、应用程序的日志对象、数据库的连接池、网站的计数器、Web 应用的配置对象、应用程序中的对话框、系统中的缓存等常常被设计成单例。 单例模式在现实生活中的应用也非常广泛，例如公司 CEO、部门经理等都属于单例模型。J2EE 标准中的 ServletContext 和 ServletContextConfig、Spring框架应用中的 ApplicationContext、数据库中的连接池等也都是单例模式。 单例模式有 3 个特点： 单例类只有一个实例对象； 该单例对象必须由单例类自行创建； 单例类对外提供一个访问该单例的全局访问点。 ","date":"2021-05-19","objectID":"/design-pattern-singleton/:1:1","tags":["design pattern","Go"],"title":"设计模式-单例模式","uri":"/design-pattern-singleton/"},{"categories":["Go语言学习","设计模式学习笔记"],"content":"优缺点 单例模式的优点： 单例模式可以保证内存里只有一个实例，减少了内存的开销。 可以避免对资源的多重占用。 单例模式设置全局访问点，可以优化和共享资源的访问。 单例模式的缺点： 单例模式一般没有接口，扩展困难。如果要扩展，则除了修改原来的代码，没有第二种途径，违背开闭原则。 在并发测试中，单例模式不利于代码调试。在调试过程中，如果单例中的代码没有执行完，也不能模拟生成一个新的对象。 单例模式的功能代码通常写在一个类中，如果功能设计不合理，则很容易违背单一职责原则。 ","date":"2021-05-19","objectID":"/design-pattern-singleton/:1:2","tags":["design pattern","Go"],"title":"设计模式-单例模式","uri":"/design-pattern-singleton/"},{"categories":["Go语言学习","设计模式学习笔记"],"content":"应用场景 单例模式的应用场景主要有以下几个方面: 需要频繁创建的一些类，使用单例可以降低系统的内存压力，减少 GC。 某类只要求生成一个对象的时候，如一个班中的班长、每个人的身份证号等。 某些类创建实例时占用资源较多，或实例化耗时较长，且经常使用。 某类需要频繁实例化，而创建的对象又频繁被销毁的时候，如多线程的线程池、网络连接池等。 频繁访问数据库或文件的对象。 对于一些控制硬件级别的操作，或者从系统上来讲应当是单一控制逻辑的操作，如果有多个实例，则系统会完全乱套。 当对象需要被共享的场合。由于单例模式只允许创建一个对象，共享该对象可以节省内存，并加快对象访问速度。如 Web 中的配置对象、数据库的连接池等。 ","date":"2021-05-19","objectID":"/design-pattern-singleton/:1:3","tags":["design pattern","Go"],"title":"设计模式-单例模式","uri":"/design-pattern-singleton/"},{"categories":["Go语言学习","设计模式学习笔记"],"content":"Go语言实现 单例对象定义: type Singleton struct { name string } 饿汉式 不管三七二十一，在程序启动时就创建好，故称 “饿汉”，简单粗暴。 var singletonHungry *Singleton // 通过 go 的 init 函数侵入 func init() { singletonHungry = \u0026Singleton{name: \"hungry\"} } func GetInstanceHungry() *Singleton { return singletonHungry } 懒汉式 与饿汉式不同，此时不在程序启动时创建，而是将初始化延迟到第一次使用的时候，即懒加载。 懒汉式经典实现方式：双重检测（需要加锁） var ( singletonLazy *Singleton mutex sync.Mutex ) func GetInstanceLazy() *Singleton { if singletonLazy == nil { mutex.Lock() // 再次判断的原因是并发情况下在外层判断为 nil 到获取锁这中间，可能已经被别的工作者初始化了 if singletonLazy == nil { singletonLazy = \u0026Singleton{name: \"lazy\"} } mutex.Unlock() } return singletonLazy } 在这里给出一种使用 atomic 原子操作来实现的版本，类似于双重检测，但是不需要加 Mutex 重锁。 var ( singletonLazy *Singleton epoch int64 ) func GetInstanceLazy() *Singleton { if singletonLazy == nil \u0026\u0026 atomic.AddInt64(\u0026epoch, 1) == 1 { singletonLazy = \u0026Singleton{name: \"lazy\"} } return singletonLazy } 最后一种懒汉式实现就是借助与 sync.Once 来保证初始化只执行一次。 var ( singletonLazyII *Singleton once sync.Once ) func GetInstanceLazyII() *Singleton { if singletonLazyII == nil { once.Do(func() { singletonLazyII = \u0026Singleton{name: \"lazy II\"} }) } return singletonLazyII } ","date":"2021-05-19","objectID":"/design-pattern-singleton/:1:4","tags":["design pattern","Go"],"title":"设计模式-单例模式","uri":"/design-pattern-singleton/"},{"categories":["Go语言学习","设计模式学习笔记"],"content":"总结 单例模式应该是设计模式里常规并且容易理解的一种了，一般应用场景就是节省资源、创建全局的枚举对象或者重要资源的初始化（如基础库的全局默认对象）。 谢谢观看～ ","date":"2021-05-19","objectID":"/design-pattern-singleton/:1:5","tags":["design pattern","Go"],"title":"设计模式-单例模式","uri":"/design-pattern-singleton/"},{"categories":null,"content":"问题背景 这是一个我在开发过程中遇到的小问题，为了简单，现假设有一张 user 表，结构如下： CREATETABLE`user`(`id`intNOTNULLAUTO_INCREMENT,`name`varchar(20)NOTNULLDEFAULT''COMMENT'用户名',`age`tinyint(4)unsignedNOTNULLDEFAULT'0'COMMENT'年龄',PRIMARYKEY(`id`),KEY`idx_name`(`name`))ENGINE=InnoDBAUTO_INCREMENT=6DEFAULTCHARSET=utf8mb4; 对应的 GORM Model： type User struct { ID int `gorm:\"primaryKey;column:id\"` Name string `gorm:\"column:name;varchar(20);not null;default\"` Age uint8 `gorm:\"column:age;tinyint unsigned;not null;default\"` } func (u User) TableName() string { return \"user\" } 在 MySQL 中年龄 age 被定义为一个 tinyint unsigned 类型，范围是 0-255 ，对应 Go 代码中定义的类型为 uint8 。 插入一条测试数据: insertinto`user`(`name`,`age`)values('heracles','23');select*from`user`where`age`IN('23')\\G; 得到现在表中的实际数据： *************************** 1. row *************************** id: 4 name: 马力神 age: 23 *************************** 2. row *************************** id: 5 name: heracles age: 23 2 rows in set (0.01 sec) 然后使用 GORM (V1) 构建查询语句，本意是使用 IN 语句并指定一个 User.Age 类型的集合来查询年龄符合的行: func main() { // 连接数据库 db, err := gorm.Open(\"mysql\", \"root:520168@/test?charset=utf8mb4\u0026parseTime=True\u0026loc=Local\") if err != nil { panic(err) } defer db.Close() user := make([]User, 0) // 开启 debug 日志 if err := db.Debug().Where(\"`age` IN (?)\", []uint8{23}).Find(\u0026user).Error; err != nil { fmt.Println(err) os.Exit(1) } fmt.Printf(\"%+v\", user) } 得到的结果是这样的: [2021-04-19 15:38:42] [1.54ms] SELECT * FROM `user` WHERE (`age` ('\u003cbinary\u003e')) [0 rows affected or returned ] [] 可以明显看到，首先生成的 SQL 语句是错乱的，自然拿不到预期结果。 然后试了下，将 db.Debug().Where(\"age IN (?)\", []uint8{23}) 中的切片改成 [ ]uint、[ ]int 等其他整型后，结果： [2021-04-19 15:53:47] [8.71ms] SELECT * FROM `user` WHERE (`age` IN (23)) [2 rows affected or returned ] [{ID:4 Name:马力神 Age:23} {ID:5 Name:heracles Age:23}] 可以看到输出符合预期了， ","date":"2021-04-19","objectID":"/gorm_20210419/:1:0","tags":null,"title":"使用GORM IN查询的一个问题","uri":"/gorm_20210419/"},{"categories":null,"content":"为什么 当时在测试时看到这个情况，第一反应就是 GORM 构建 SQL 语句的某个部分，通过类型断言处理的逻辑和自己想象的不一样，于是开始 Debug , 追踪源码: Where()中定义的查询条件会被保存在 gorm/search.whereConditions的一个 map 中： func (s *DB) Where(query interface{}, args ...interface{}) *DB { return s.clone().search.Where(query, args...).db } func (s *search) Where(query interface{}, values ...interface{}) *search { s.whereConditions = append(s.whereConditions, map[string]interface{}{\"query\": query, \"args\": values}) return s } 然后在 Find() 中会在 queryCallback() 查询回调中通过 prepareQuerySQL() 对查询条件进行构建： // queryCallback used to query data from database func queryCallback(scope *Scope) { ... scope.prepareQuerySQL() ... } 最终在 CombinedConditionSql() 中的 whereSQL() 对 whereConditions 中的键值对进行处理: func (scope *Scope) whereSQL() (sql string) { ... for _, clause := range scope.Search.whereConditions { if sql := scope.buildCondition(clause, true); sql != \"\" { andConditions = append(andConditions, sql) } } ... } func (scope *Scope) buildCondition(clause map[string]interface{}, include bool) (str string) { ... replacements := []string{} args := clause[\"args\"].([]interface{}) for _, arg := range args { var err error switch reflect.ValueOf(arg).Kind() { case reflect.Slice: // For where(\"id in (?)\", []int64{1,2}) if scanner, ok := interface{}(arg).(driver.Valuer); ok { arg, err = scanner.Value() replacements = append(replacements, scope.AddToVars(arg)) } else if b, ok := arg.([]byte); ok { replacements = append(replacements, scope.AddToVars(b)) } else if as, ok := arg.([][]interface{}); ok { ... } else if values := reflect.ValueOf(arg); values.Len() \u003e 0 { var tempMarks []string for i := 0; i \u003c values.Len(); i++ { tempMarks = append(tempMarks, scope.AddToVars(values.Index(i).Interface())) } replacements = append(replacements, strings.Join(tempMarks, \",\")) } else { replacements = append(replacements, scope.AddToVars(Expr(\"NULL\"))) } ... } default: } return } 在这里，程序按预期的进入了 case reflect.Slice 分支，由于 [ ]uint8 没有实现标准数据库驱动库的 driver.Valuer 接口，接着在下一步 else if b, ok := arg.([]byte); ok 这里命中，这个 [ ]uint8 的参数会被当成一个 replacement元素，后续在 where(query, args...) 中的 query 中对应的位置填充，可以说 uint8 类型的切片被当成一个字符串而不是多个 uint8 的元素集合。 而如果是非 uint8 类型的切片，会进入 else if values := reflect.ValueOf(arg); values.Len() \u003e 0 分支，相应的处理是将切片的每一个元素当成一个属性值，用 ,拼接起来再填充到 query 中的相应位置。 所以对于 Where(\"age IN (?)\",[]int{23,26}) ，转换后的结果 select*from`user`where`age`IN('23','26'); 而对于 Where(\"age IN (?)\",[]uint8{23,26}) ，转换后的结果 select*from`user`where`age`IN('TBSUB'); []uint8 对应的是 ascii 码，所以 23 和 26 分别对应不可见字符 ‘TB’ 和 ‘SUB’，可以用 0-32 以外的可见字符试一下，比如 98(‘b’) 和 99(‘c’')，对应的结果 sql 语句就为: [2021-04-19 17:30:31] [2.08ms] SELECT * FROM `user` WHERE (`age` IN ('bc')) 至于 [ ]uint8 和 [ ]byte 等同，是因为在 Go 语言中的 byte 类型就是 uint8 的一个别名，见内建类型包 builtin : // byte is an alias for uint8 and is equivalent to uint8 in all ways. It is // used, by convention, to distinguish byte values from 8-bit unsigned // integer values. type byte = uint8 ","date":"2021-04-19","objectID":"/gorm_20210419/:2:0","tags":null,"title":"使用GORM IN查询的一个问题","uri":"/gorm_20210419/"},{"categories":null,"content":"总结 由于在 Go 语言中，uint8 和 byte 本质上完全等同，所以使用 uint8 命中类型断言后的 byte 类型。 在 GORM 和 Go 标准 database/driver 库中，对于 byte 的处理其实和 string 类似，并不会按文中设想的将每一个 uint8 元素当成 IN 的匹配元素 (然后用英文 , 分隔)，而是将整个 byte 当成一个匹配元素。 为了节省内存而定义一些 uint8 类型的实体 model 属性，在使用 GORM 的 Where() 构建 IN 查询时，一定要转换成其他的整型切片类型。 ","date":"2021-04-19","objectID":"/gorm_20210419/:3:0","tags":null,"title":"使用GORM IN查询的一个问题","uri":"/gorm_20210419/"},{"categories":["Go语言学习"],"content":"什么是并发编程 并发 concurrency 是一种设计： 将程序设计成一个包含许多独立过程的集合； 允许这些过程最终可以并行 parallel 地去执行； 尽管 并发 并不要求必须同时运行，例如在单核 CPU 物理机上无法实现并行却可以依靠操作系统时间片轮转等调度来实现并发； 并发是一种操作系统在时间维度的虚拟，即时分复用。 代码运行的结果总是相同，无论是以并行还是顺序的方式。 ","date":"2021-01-10","objectID":"/concurrency/:1:0","tags":["concurrency","Go"],"title":"Concurrency Patterns In Go","uri":"/concurrency/"},{"categories":["Go语言学习"],"content":"具体要求 通过划分多个独立的任务来将代码以及数据分组 没有竞争条件1 没有死锁2 比常规的程序更有效，即执行更快 ","date":"2021-01-10","objectID":"/concurrency/:2:0","tags":["concurrency","Go"],"title":"Concurrency Patterns In Go","uri":"/concurrency/"},{"categories":["Go语言学习"],"content":"Go如何并发 Don’t communicate by sharing memory; share memory by communicating. (R. Pike) 不要通过共享内存来通信，这意味着不同的并发实体不应该通过遵守严格、容易出错的内存可见性和同步策略 (比如内存屏障3)来进行通信 (这是可以做到的，但是会让情况变得复杂，而且由于数据竞争会造成不可预期的结果)。 应该通过通信来共享内存 (数据) : Go 使用了基于 CSP4 (Communicating Sequential Process，通信顺序程序) 的并发模型，goroutine 做为并发通信的实体，通过 channel 来实现数据共享。 A send on a channel happens before the corresponding receive from that channel completes. (Golang Spec) happens before 保证了一个 goroutine 对 channel 的写入对另一个 goroutine 的读取操作是可见的。这是一种简单的顺序传递模式，由于 goroutine 之间通过 channel 来共享对内存的引用 (通过拷贝)，所以没有修改共享内存，也就不需要 mutex 之类的同步操作。理想中的 Go 并发，应该没有共享空间，每个并发主体 goroutine 仅能看到自己拥有的内存部分。 ","date":"2021-01-10","objectID":"/concurrency/:3:0","tags":["concurrency","Go"],"title":"Concurrency Patterns In Go","uri":"/concurrency/"},{"categories":["Go语言学习"],"content":"channel 无缓冲通道 向无缓冲通道发送和从无缓冲通道中读取都会被阻塞，知道发送方和接收方同时准备好，才得意继续运行，就像同一赛道上两个交接接力棒的运动员。 ch := make(chan int) ch \u003c- 10 $ fatal error: all goroutines are asleep - deadlock! ch := make(chan int) \u003c-ch $ fatal error: all goroutines are asleep - deadlock! ch := make(chan string) go func() { msg := \u003c-ch fmt.Println(msg) }() ch \u003c- \"hello world\" $ hello world 缓冲通道 当缓冲区已满时向通道发送数据 或者 从通道读取数据时缓冲区为空 (没有数据就意味着阻塞，同样体现为，不使用 make 初始化一个通道，从此通道读取数据将导致程序永久阻塞 )，程序会阻塞，其余情况下可以继续运行。 ch := make(chan int, 2) ch \u003c- 1 fmt.Println(\"send 1 unblocking...\") ch \u003c- 2 fmt.Println(\"send 2 unblocking...\") ch \u003c- 3 fmt.Println(\"send 3 unblocking...\") $ send 1 unblocking... $ send 2 unblocking... $ fatal error: all goroutines are asleep - deadlock! 已关闭通道 使用 close(ch chan) 可以将通道 ch 关闭。 从已关闭通道读取，总能得到返回。第一个返回值是通道类型对应的零值，第二个返回值是一个 boolean 类型的 false，代表数据不可用，通道未关闭时其为 true 。 ch := make(chan int) close(ch) for i := 0; i \u003c 3; i++ { val, ok := \u003c-ch fmt.Println(val, ok) } $ 0 false $ 0 false $ 0 false 向已关闭的通道发送数据，会引起运行时恐慌 panic： ch := make(chan int) close(ch) ch \u003c- 1024 $ panic: send on closed channel ","date":"2021-01-10","objectID":"/concurrency/:3:1","tags":["concurrency","Go"],"title":"Concurrency Patterns In Go","uri":"/concurrency/"},{"categories":["Go语言学习"],"content":"select select 的语法结构和 switch 很像，不过它是专门用来进行通道的接收、发送操作的。 ch := make(chan int) select { case \u003c-ch: } // 此代码会永久阻塞 $ fatal error: all goroutines are asleep - deadlock! select 会在某个 case 的通道收发操作准备好时进入分支执行，当没有任何一个分支准备好时，程序会阻塞并等待。当有多个分支同时准备好时，会随机选择一个分支执行，注意，执行顺序并非按照书写 case 的顺序，此机制可以防止饥饿。 ch := make(chan int, 5) done := make(chan struct{}) defer close(ch) go func() { for { select { case \u003c-ch: fmt.Println(\"choose case a\") case \u003c-ch: fmt.Println(\"choose case b\") case \u003c-done: return } } }() for i := 0; i \u003c 5; i++ { ch \u003c- i } time.Sleep(time.Second) close(done) $ choose case b $ choose case a $ choose case b $ choose case b $ choose case a select 可以实现非阻塞通道收发操作，只需要添加一个 default 分支。 ch := make(chan int) select { case \u003c-ch: default: fmt.Println(\"enter default case\") } $ enter default case ","date":"2021-01-10","objectID":"/concurrency/:3:2","tags":["concurrency","Go"],"title":"Concurrency Patterns In Go","uri":"/concurrency/"},{"categories":["Go语言学习"],"content":"使用 channel 应该注意什么 不要造成死锁。 channel 涉及很多阻塞，请确保各种通信方之间的顺序在掌控之中，否则可能造成死锁而无法推进。 数据在 channel 中传递同样是值拷贝，因此当传递一些大对象时，请考虑性能影响。 通过 channel 传递指针会打破不同并发主体之间的内存隔离，造成数据竞争，不要这样做。 ","date":"2021-01-10","objectID":"/concurrency/:3:3","tags":["concurrency","Go"],"title":"Concurrency Patterns In Go","uri":"/concurrency/"},{"categories":["Go语言学习"],"content":"原子操作 程序演进的三种类型: Blocking：程序可能进入时间未知的阻塞状态而无法推进 (make progress)，比如使用 mutex/lock。 Lock free：程序中至少有一部分 (一个或多个并发主体)总是在向前推进，通过不使用 mutex 而是 CAS (Compare And Swap) 来实现。 Wait free：程序中的每一个部分 (每一个并发主体)都能在有限的步骤或者时间内向前推进。有兴趣可以转向 Lock-Free Single-Producer - Single Consumer Circular Queue。 接入来介绍几种借助 Go 的 atomic package 来实现的 lock free 并发模式。 Spinning CAS 自旋锁 使用 CAS 实现最简单的自旋锁只需要两个东西：一个表示状态的变量以及一个表示 free 状态的常量。 const free = int32(0) // 定义无争用状态 type Spinlock struct { state int32 } func (sl *Spinlock) Lock() { for !atomic.CompareAndSwapInt32(\u0026sl.state, free, 1) { // 1可以是任何不等于 free(0) 的值 runtime.Gosched() // 主动让出cpu，此操作不会导致当前协程挂起，其会自动恢复运行 } } func (sl *Spinlock) Unlock() { atomic.StoreInt32(\u0026sl.state, free) } 以上就是一个简单的自旋锁的实现，来看一下实现的效果。 下面的这段代码在没有使用任何锁的情况下，可能会导致最终的结果不为0，用例少时可能观察不出来，我们让它运行在一个较大的循环。 func main() { passed := 0 for i := 0; i \u003c 1000000; i++ { man := \u0026Man{} wg := sync.WaitGroup{} wg.Add(2) go func() { defer wg.Done() man.DecrMoney() // 对金额减1 }() go func() { defer wg.Done() man.IncrMoney() // 对金额加1 }() wg.Wait() // 此时预期的 man.money 值应该为0 if man.money != 0 { fmt.Printf(\"passedStep: %d\\nunexpeted man's money：%d\", passed, man.money) return } passed++ } fmt.Printf(\"all cases pass：%d\", passed) } type Man struct { Spinlock money int } func (m *Man) DecrMoney() { // m.Lock() m.money -= 1 // m.Unlock() } func (m *Man) IncrMoney() { // m.Lock() m.money += 1 // m.Unlock() } 使用 -race 选项启用 Go 的 data race 检测，此时的输出很有可能是： $ go run -race main.go # 输出 $ WARNING: DATA RACE $ Read at 0x00c00001c0a8 by goroutine 8: $ main.(*Man).IncrMoney() $ /Users/malishen/go/src/awesomeProject/main.go:48 +0x7b $ main.main.func2() $ /Users/malishen/go/src/awesomeProject/main.go:23 +0x69 ... $ passedStep: 23517 $ unexpeted man's money：1 $ Process finished with exit code 1 当启动 Spinlock 后： func (m *Man) DecrMoney() { m.Lock() m.money -= 1 m.Unlock() } func (m *Man) IncrMoney() { m.Lock() m.money += 1 m.Unlock() } 此时的结果无论循环变量 i 设置多大，结果都是： $ go run -race main.go # 输出,没有 data race $ all cases pass：1000000 Ticket Storage 再来使用 CAS 实现一个 lock free 的本地存储，并且具有先到先得的顺序公平性，需要一个线性的结构以及一个 ticket 变量和 done 变量。 type TicketStorage struct { ticket uint64 // 任务号，只增不减 done uint64 // 已经完成的任务 slots []string // 为了简单，这里想象成是无限容量的 } func (ts *TicketStorage) Put(msg string) { t := atomic.AddUint64(\u0026ts.ticket, 1) - 1 // 减1是获取到的ticket对应的slots下标 ts.slots[t] = msg for !atomic.CompareAndSwapUint64(\u0026ts.done, t, t+1) { runtime.Gosched() } } func (ts *TicketStorage) GetDone() []string { return ts.slots[:atomic.LoadUint64(\u0026ts.done)+1] } Note：上面这个 demo 仅仅是一个并发设计模式的演示，由于 slots 其实并不是一个无限容量的切片，所以此代码是无法直接运行的。 总结一下，这个 Ticket Storage 在 Put() 时，ticket 原子地单调递增，所以其是全局唯一的，从而保证在对 slots 相应索引赋值时没有 data race。类似于很多人去银行排队办理业务，银行只有一个窗口，所以每个人可以先取一个号，等叫到号了才可以去办理业务。这个模式的最大特点是对于 GetDone()的读取操作，是 wait free 的，可以仔细体会一下。 ","date":"2021-01-10","objectID":"/concurrency/:3:4","tags":["concurrency","Go"],"title":"Concurrency Patterns In Go","uri":"/concurrency/"},{"categories":["Go语言学习"],"content":"总结 CSP 是 Go 并发理论的基石，Go 向开发者提供了强大的轻量级线程 goroutine 和 通道 channel 让并发编程变得简单、高效，但是这种简单性意味着难以深入掌握，在这里给出几个建议： 避免阻塞，避免数据竞争 data race； 使用 channel 进行通信而不是直接共享内存，使用 select 去管理 channel，channel 应该由创建者/发送方决定何时关闭； 当某些场景 channel 无法很好地帮助你时： 优先使用 sync 并发工具包； 在简单情况下或者确实需要时，尝试使用 atomic 写出 lock free 的代码。 参考资料 The Go Memory Model https://golang.org/ref/mem 《 Go 语言设计与实现》https://draveness.me/golang/docs/part2-foundation/ch05-keyword/golang-select/ 深入golang之—goroutine并发控制与通信, 知乎 https://zhuanlan.zhihu.com/p/36907022 Share Memory By Communicating, The Go Blog https://blog.golang.org/codelab-share 为什么使用通信来共享内存 https://draveness.me/whys-the-design-communication-shared-memory/ 数据竞争 https://zh.wikipedia.org/wiki/%E7%AB%B6%E7%88%AD%E5%8D%B1%E5%AE%B3 ↩︎ 死锁 https://zhuanlan.zhihu.com/p/26945588 ↩︎ 内存屏障 https://zh.wikipedia.org/wiki/%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C ↩︎ CSPhttps://zh.wikipedia.org/wiki/%E4%BA%A4%E8%AB%87%E5%BE%AA%E5%BA%8F%E7%A8%8B%E5%BC%8F ↩︎ ","date":"2021-01-10","objectID":"/concurrency/:3:5","tags":["concurrency","Go"],"title":"Concurrency Patterns In Go","uri":"/concurrency/"}]